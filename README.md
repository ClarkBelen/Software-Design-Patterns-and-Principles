# ‚òï Software Design Patterns and Principles in JAVA OOP
This repository serves as a compilation of examples demonstrating the most common Design Patterns and the SOLID Principles in Java. 

This collection is designed for students, developers, or anyone who wants to understand and apply Object-Oriented Programming (OOP) best practices in Java.

## üì¶ Creational Design Patterns
1. [Factory Pattern](https://github.com/ClarkBelen/factoryPattern) - provides an interface for creating objects but allows subclasses to alter the type of objects that will be created.
2. [Singleton Pattern](https://github.com/ClarkBelen/singletonPattern) - ensures a class has only one instance and provides a global point of access to that instance.
3. [Builder Pattern](https://github.com/ClarkBelen/builderPattern) - constructs complex objects step by step, allowing different representations using the same process.
   
## üèó Structural Design Patterns
1. [Adapter Pattern](https://github.com/ClarkBelen/adapterPattern) - allows objects with incompatible interfaces to work together.
2. [Facade Pattern](https://github.com/ClarkBelen/facadePattern) - provides a unified interface to a set of interfaces in a subsystem.
3. [Decorator Pattern](https://github.com/ClarkBelen/decoratorPattern) - allows the behavior of an object to be extended dynamically, without the need to change its source code. 

## üîÑ Behavioral Design Patterns
1. [Command Pattern](https://github.com/ClarkBelen/commandPattern) - encapsulating all the data related to command in one object.
2. [Observer Pattern](https://github.com/ClarkBelen/observerPattern) - defines a one-to-many dependency between objects.
3. [Strategy Pattern](https://github.com/ClarkBelen/strategyPattern) - defines a family of algorithms and makes them interchangeable at runtime.
4. [State Pattern](https://github.com/ClarkBelen/statePattern) - allows an object to change its behavior when its state changes.
5. [Visitor Pattern](https://github.com/ClarkBelen/visitorPattern) - separates algorithms from the objects on which they operate.

## üìê SOLID Design Principles
The SOLID principles are a set of five design principles intended to make software designs more understandable, flexible, and maintainable:
1. Single Responsibility Principle (SRP) - a class should have only one reason to change.
2. Open/Closed Principle (OCP) - software entities should be open for extension but closed for modification.
3. Liskov Substitution Principle (LSP) -  derived classes must be substitutable for their base classes.
4. Interface Segregation Principle (ISP) - no client should depend on methods it does not use.
5. Dependency Inversion Principle (DIP) - high-level modules should not depend on low-level modules; both should depend on abstractions.

### üìù Example Implementations
These examples demonstrate applying SOLID principles in real-world scenarios:
- [SOLID Principles](https://github.com/ClarkBelen/SOLID-Principles) - improves an Order system by applying SRP, OCP, and DIP to create a cleaner and more maintainable design.

- [SOLID with Design Pattern](https://github.com/ClarkBelen/SOLID-with-Design-Pattern) - refactors a library system using SOLID principles, focusing on DIP for flexible resource management.

## üìò About
This repository is part of my personal learning journey to master Software Design Patterns and Principles in Java OOP. It aims to serve as a reference for others who want to study or review these concepts.

Each link above points to a dedicated repository containing:

‚úÖ Source code

‚úÖ UML Class Diagram

‚úÖ Example use cases

‚úÖ Documentation

